{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "liquid-glass-button-variants",
  "type": "registry:component",
  "title": "Liquid Glass Button - Variants",
  "description": "Liquid glass button with different style variants.",
  "files": [
    {
      "path": "registry/new-york/components/liquid-glass-button/liquid-glass-button.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport { Slot } from \"@radix-ui/react-slot\";\nimport { cva, type VariantProps } from \"class-variance-authority\";\n\nimport { cn } from \"@/lib/utils\";\n\nconst liquidGlassButtonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive relative overflow-hidden\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"bg-background/20 hover:bg-background/30 dark:bg-background/20 dark:hover:bg-background/30\",\n        ghost:\n          \"bg-transparent border border-transparent hover:bg-background/30 dark:hover:bg-background/30\",\n      },\n      size: {\n        default: \"h-9 px-4 py-2 has-[>svg]:px-3\",\n        sm: \"h-8 gap-1.5 px-3 has-[>svg]:px-2.5\",\n        lg: \"h-10 px-6 has-[>svg]:px-4\",\n        icon: \"size-9 rounded-md\",\n        \"icon-sm\": \"size-8 rounded-md\",\n        \"icon-lg\": \"size-10 rounded-md\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n);\n\ninterface LiquidGlassButtonProps\n  extends React.ComponentProps<\"button\">,\n    VariantProps<typeof liquidGlassButtonVariants> {\n  asChild?: boolean;\n  distortionStrength?: number;\n  borderRadius?: number;\n  blur?: number;\n  brightness?: number;\n  textClassName?: string;\n}\n\n// Utility functions for shader math\nfunction smoothStep(a: number, b: number, t: number): number {\n  t = Math.max(0, Math.min(1, (t - a) / (b - a)));\n  return t * t * (3 - 2 * t);\n}\n\nfunction length(x: number, y: number): number {\n  return Math.sqrt(x * x + y * y);\n}\n\nfunction roundedRectSDF(\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  radius: number\n): number {\n  const qx = Math.abs(x) - width + radius;\n  const qy = Math.abs(y) - height + radius;\n  return (\n    Math.min(Math.max(qx, qy), 0) +\n    length(Math.max(qx, 0), Math.max(qy, 0)) -\n    radius\n  );\n}\n\nfunction texture(x: number, y: number): { type: string; x: number; y: number } {\n  return { type: \"t\", x, y };\n}\n\nconst LiquidGlassButton = React.forwardRef<\n  HTMLButtonElement,\n  LiquidGlassButtonProps\n>(\n  (\n    {\n      className,\n      variant,\n      size,\n      asChild = false,\n      distortionStrength: distortionStrengthProp,\n      borderRadius: borderRadiusProp,\n      blur: blurProp,\n      brightness: brightnessProp,\n      textClassName,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    // Use useMemo to ensure stable references for dependency arrays\n    // All variants use the same distortion and border radius defaults\n    const distortionStrength = React.useMemo(\n      () =>\n        distortionStrengthProp !== undefined ? distortionStrengthProp : 1.0,\n      [distortionStrengthProp]\n    );\n    const borderRadius = React.useMemo(\n      () => (borderRadiusProp !== undefined ? borderRadiusProp : 0.6),\n      [borderRadiusProp]\n    );\n    const blur =\n      blurProp !== undefined ? blurProp : variant === \"ghost\" ? 1.0 : 0.25;\n    const brightness =\n      brightnessProp !== undefined\n        ? brightnessProp\n        : variant === \"ghost\"\n        ? 1.0\n        : 1.2;\n    const containerRef = React.useRef<HTMLButtonElement>(null);\n    const svgRef = React.useRef<SVGSVGElement>(null);\n    const canvasRef = React.useRef<HTMLCanvasElement>(null);\n    // Use React's useId() for stable, hydration-safe unique IDs\n    const reactId = React.useId();\n    const uniqueId = `liquid-glass-${reactId.replace(/:/g, \"-\")}`;\n\n    const updateShader = React.useCallback(() => {\n      const canvas = canvasRef.current;\n      const svg = svgRef.current;\n      const container = containerRef.current;\n\n      if (!canvas || !svg || !container) return;\n\n      const containerRect = container.getBoundingClientRect();\n      const width = Math.floor(containerRect.width);\n      const height = Math.floor(containerRect.height);\n\n      if (width === 0 || height === 0) return;\n\n      const canvasDPI = 1; // Match vanilla example\n      const w = width * canvasDPI;\n      const h = height * canvasDPI;\n\n      canvas.width = w;\n      canvas.height = h;\n      const context = canvas.getContext(\"2d\");\n      if (!context) return;\n\n      // Update SVG filter dimensions to match button size (userSpaceOnUse)\n      const filterEl = svg.querySelector(`#${uniqueId}_filter`);\n      if (filterEl instanceof SVGFilterElement) {\n        filterEl.setAttribute(\"x\", \"0\");\n        filterEl.setAttribute(\"y\", \"0\");\n        filterEl.setAttribute(\"width\", width.toString());\n        filterEl.setAttribute(\"height\", height.toString());\n      }\n\n      // Update feImage dimensions\n      const feImage = svg.querySelector(`#${uniqueId}_map`);\n      if (feImage instanceof SVGFEImageElement) {\n        feImage.setAttribute(\"width\", width.toString());\n        feImage.setAttribute(\"height\", height.toString());\n      }\n\n      const data = new Uint8ClampedArray(w * h * 4);\n      let maxScale = 0;\n      const rawValues: number[] = [];\n\n      // Fragment shader matching vanilla example exactly\n      for (let i = 0; i < data.length; i += 4) {\n        const x = (i / 4) % w;\n        const y = Math.floor(i / 4 / w);\n        const uv = { x: x / w, y: y / h };\n\n        // Convert to centered coordinates (exact match to vanilla)\n        const ix = uv.x - 0.5;\n        const iy = uv.y - 0.5;\n\n        // Use fixed SDF dimensions like vanilla example (can be adjusted via borderRadius prop)\n        const sdfWidth = 0.3;\n        const sdfHeight = 0.2;\n        const sdfRadius = borderRadius;\n\n        const distanceToEdge = roundedRectSDF(\n          ix,\n          iy,\n          sdfWidth,\n          sdfHeight,\n          sdfRadius\n        );\n\n        // Control displacement strength with distortionStrength prop (maps to vanilla's 0.15)\n        // When distortionStrength is 0, no distortion should be applied\n        let pos;\n        if (distortionStrength === 0) {\n          // No distortion: return original texture coordinates\n          pos = texture(uv.x, uv.y);\n        } else {\n          const displacementAmount = distortionStrength * 0.15;\n          const displacement = smoothStep(\n            0.8,\n            0,\n            distanceToEdge - displacementAmount\n          );\n          const scaled = smoothStep(0, 1, displacement);\n          // Return texture coordinates\n          pos = texture(ix * scaled + 0.5, iy * scaled + 0.5);\n        }\n\n        // Calculate displacement from original position\n        const dx = pos.x * w - x;\n        const dy = pos.y * h - y;\n\n        // Negate displacement to invert the effect (bulge outward instead of pinch inward)\n        const invertedDx = -dx;\n        const invertedDy = -dy;\n\n        maxScale = Math.max(\n          maxScale,\n          Math.abs(invertedDx),\n          Math.abs(invertedDy)\n        );\n        rawValues.push(invertedDx, invertedDy);\n      }\n\n      // Normalize displacement map\n      maxScale *= 0.5;\n\n      let index = 0;\n      for (let i = 0; i < data.length; i += 4) {\n        // Handle zero displacement case (when distortionStrength = 0)\n        if (maxScale === 0) {\n          data[i] = 128; // 0.5 * 255 = no displacement\n          data[i + 1] = 128;\n          data[i + 2] = 0;\n          data[i + 3] = 255;\n          index += 2; // Skip the raw values we're not using\n        } else {\n          const r = rawValues[index++] / maxScale + 0.5;\n          const g = rawValues[index++] / maxScale + 0.5;\n          data[i] = r * 255;\n          data[i + 1] = g * 255;\n          data[i + 2] = 0;\n          data[i + 3] = 255;\n        }\n      }\n\n      context.putImageData(new ImageData(data, w, h), 0, 0);\n\n      const feDisplacementMap = svg.querySelector(\n        `#${uniqueId}_filter feDisplacementMap`\n      );\n\n      if (feImage && feDisplacementMap) {\n        // Create data URL from canvas (exact match to vanilla example)\n        const dataUrl = canvas.toDataURL();\n\n        // Update feImage (exact match to vanilla example - only namespaced version)\n        feImage.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", dataUrl);\n\n        if (feDisplacementMap instanceof SVGFEDisplacementMapElement) {\n          // Calculate displacement scale\n          const displacementScale = (maxScale / canvasDPI).toString();\n          feDisplacementMap.setAttribute(\"scale\", displacementScale);\n        }\n      }\n    }, [uniqueId, distortionStrength, borderRadius]);\n\n    // Initial shader update and resize observer\n    React.useEffect(() => {\n      // Initial update\n      updateShader();\n\n      // Update on resize\n      const resizeObserver = new ResizeObserver(() => {\n        updateShader();\n      });\n\n      if (containerRef.current) {\n        resizeObserver.observe(containerRef.current);\n      }\n\n      return () => {\n        resizeObserver.disconnect();\n      };\n    }, [updateShader]);\n\n    // Update shader when props change\n    // Note: We only need updateShader here since it already depends on distortionStrength and borderRadius\n    React.useEffect(() => {\n      updateShader();\n    }, [updateShader]);\n\n    const Comp = asChild ? Slot : \"button\";\n\n    // Combine refs for containerRef and external ref\n    const handleRef = React.useCallback(\n      (node: HTMLButtonElement | null) => {\n        containerRef.current = node;\n        if (typeof ref === \"function\") {\n          ref(node);\n        } else if (ref) {\n          ref.current = node;\n        }\n      },\n      [ref]\n    );\n\n    return (\n      <>\n        {/* Hidden SVG with filter definition */}\n        <svg\n          ref={svgRef}\n          width=\"0\"\n          height=\"0\"\n          style={{\n            position: \"fixed\",\n            top: 0,\n            left: 0,\n            pointerEvents: \"none\",\n            zIndex: -1,\n          }}\n        >\n          <defs>\n            <filter\n              id={`${uniqueId}_filter`}\n              filterUnits=\"userSpaceOnUse\"\n              colorInterpolationFilters=\"sRGB\"\n              x=\"0\"\n              y=\"0\"\n              width=\"100\"\n              height=\"100\"\n            >\n              <feImage id={`${uniqueId}_map`} width=\"100\" height=\"100\" />\n              <feDisplacementMap\n                in=\"SourceGraphic\"\n                in2={`${uniqueId}_map`}\n                xChannelSelector=\"R\"\n                yChannelSelector=\"G\"\n                scale=\"0\"\n              />\n            </filter>\n          </defs>\n        </svg>\n\n        {/* Hidden canvas for displacement map */}\n        <canvas ref={canvasRef} style={{ display: \"none\" }} />\n\n        {/* Button with liquid glass effect */}\n        <Comp\n          ref={asChild ? undefined : handleRef}\n          className={cn(\n            liquidGlassButtonVariants({ variant, size }),\n            \"relative\",\n            className\n          )}\n          style={{\n            boxShadow:\n              variant === \"ghost\"\n                ? \"none\"\n                : `\n              0 4px 8px rgba(0, 0, 0, 0.25),\n              0 -10px 25px inset rgba(0, 0, 0, 0.15),\n              0 -1px 4px 1px inset rgba(255, 255, 255, 0.1)\n            `,\n            backdropFilter: `url(#${uniqueId}_filter) blur(${blur}px) brightness(${brightness})`,\n            WebkitBackdropFilter: `url(#${uniqueId}_filter) blur(${blur}px) brightness(${brightness})`,\n          }}\n          {...props}\n        >\n          {/* Content (not distorted) - only render if children exist */}\n          {children && (\n            <span\n              className={cn(\n                \"relative z-10 inline-flex items-center gap-2\",\n                textClassName || \"text-foreground\"\n              )}\n            >\n              {children}\n            </span>\n          )}\n        </Comp>\n      </>\n    );\n  }\n);\n\nLiquidGlassButton.displayName = \"LiquidGlassButton\";\n\nexport { LiquidGlassButton, liquidGlassButtonVariants };\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/components/liquid-glass-button/variants-demo.tsx",
      "content": "\"use client\";\n\nimport Image from \"next/image\";\nimport { LiquidGlassButton } from \"./liquid-glass-button\";\nimport { OpenInV0Button } from \"@/components/open-in-v0-button\";\n\nexport function LiquidGlassVariantsDemo() {\n  return (\n    <>\n      <div className=\"absolute top-4 right-4 z-10\">\n        <OpenInV0Button name=\"liquid-glass-button-variants\" />\n      </div>\n      <div className=\"relative w-full h-[600px] md:h-[700px] overflow-hidden rounded-lg border\">\n      {/* Background image */}\n      <Image\n        src=\"/images/wave-bg.jpg\"\n        alt=\"Background\"\n        fill\n        className=\"object-cover\"\n        priority\n      />\n\n      {/* Centered buttons */}\n      <div className=\"relative flex flex-wrap gap-4 items-center justify-center h-full p-8 z-10\">\n        <LiquidGlassButton variant=\"default\" textClassName=\"text-white\">\n          Default\n        </LiquidGlassButton>\n        <LiquidGlassButton variant=\"ghost\" textClassName=\"text-white\">\n          Ghost\n        </LiquidGlassButton>\n      </div>\n    </div>\n    </>\n  );\n}\n",
      "type": "registry:component"
    }
  ]
}